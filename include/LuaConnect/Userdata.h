///////////////////////////////////////////////////////////////////////////////////////////////////
/// LuaConnect/Userdata.h
///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef LUACONNECT_USERDATA
#define LUACONNECT_USERDATA

#include "Config.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Preprocessor
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "Helpers\Ref.h"

#include <memory>
#include <tuple>

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Forward Declarations
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace LuaConnect
{
    class State;
    class VM;
    class Table;
}

namespace LuaConnect
{
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Class - Userdata
    ///////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T>
    class LUACONNECT_API Userdata : private Ref
    {
        template <typename T>
        friend class Stack;
        template <typename T>
        friend class Type;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Static Members
    ///////////////////////////////////////////////////////////////////////////////////////////////
    public:
        static Userdata<T> CreateCopy(VM& vm, const T& value);
        static Userdata<T> CreateRef(VM& vm, const T& value);

        template <typename U>
        static Userdata<T> CreateCustomCopy(VM& vm, const T& value);
        static Userdata<T> CreateCustomCopy(VM& vm, const T& value, const Table& metatable);
        template <typename U>
        static Userdata<T> CreateCustomRef(VM& vm, const T& value);
        static Userdata<T> CreateCustomRef(VM& vm, const T& value, const Table& metatable);

    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Members
    ///////////////////////////////////////////////////////////////////////////////////////////////
    private:
        Userdata(std::shared_ptr<State> state);
        template <typename... Args>
        Userdata(std::shared_ptr<State> state, std::tuple<const Args&...> args);

        void SetMetatable(const Table& metatable);

    public:
        Userdata();
        Userdata(Userdata<T>&& other);
        template <typename... Args>
        Userdata(VM& vm, const Args&... args);

        Userdata<T>& operator=(Userdata<T>&& other);

        bool operator==(const Userdata<T>& rhs) const;
        bool operator!=(const Userdata<T>& rhs) const;

        T* GetPointer();
    };
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Inline Includes
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "Userdata.inl"

#endif LUACONNECT_USERDATA
