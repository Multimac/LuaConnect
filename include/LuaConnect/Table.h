///////////////////////////////////////////////////////////////////////////////////////////////////
/// LuaConnect/Table.h
///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef LUACONNECT_TABLE
#define LUACONNECT_TABLE

#include "Config.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Preprocessor
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "Helpers\Ref.h"

#include <memory>

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Forward Declarations
///////////////////////////////////////////////////////////////////////////////////////////////////
namespace LuaConnect
{
    class State;
    class VM;
}

namespace LuaConnect
{
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Class - Table
    ///////////////////////////////////////////////////////////////////////////////////////////////
    class LUACONNECT_API Table : private Ref
    {
        template <typename T>
        friend class Stack;
        template <typename T>
        friend class Userdata;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Nested Types
    ///////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////////////////////////////////
        /// Struct - CallHandler
        ///////////////////////////////////////////////////////////////////////////////////////////
        template <typename R, typename K, typename... Args>
        struct CallHandler
        {
            static R Call(Table& table, K key, const Args&... args);
        };
        template <typename K, typename... Args>
        struct CallHandler<void, K, Args...>
        {
            static void Call(Table& table, K key, const Args&... args);
        };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    /// Members
    ///////////////////////////////////////////////////////////////////////////////////////////////
    private:
        Table(std::shared_ptr<State> state);

    public:
        Table();
        Table(Table&& other);
        Table(VM& vm);

        Table& operator=(Table&& other);

        bool operator==(const Table& rhs) const;
        bool operator!=(const Table& rhs) const;

        template <typename K>
        bool Exists(const K& key);
        template <typename V, typename K>
        V Get(const K& key);
        template <typename V, typename K>
        void Set(const K& key, const V& value);

        template <typename R, typename K, typename... Args>
        R Call(const K& key, const Args&... args);
    };
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/// Inline Includes
///////////////////////////////////////////////////////////////////////////////////////////////////
#include "Table.inl"

#endif LUACONNECT_TABLE
